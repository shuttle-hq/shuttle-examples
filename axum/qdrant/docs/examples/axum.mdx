---
title: "Axum"
description:
  "Axum is a web application framework that focuses on ergonomics and
  modularity."
---

This section revolves around simple Axum examples you can get quickly started with by following these 3 steps:
1. Initialize a new Axum project by running the `cargo shuttle init --template axum` command
2. Copy pasting the contents of the example you want to deploy -- make sure to check the tabs of the snippet(s) to ensure you are copying the right code/file
3. Running the `cargo shuttle deploy` command

<Tip>If you are looking for step-by-step guides, check out our [How To](../tutorials) section.</Tip>

## Hello world!

```Rust src/main.rs
use axum::{routing::get, Router};

async fn hello_world() -> &'static str {
    "Hello, world!"
}

#[shuttle_runtime::main]
async fn axum() -> shuttle_axum::ShuttleAxum {
    let router = Router::new().route("/hello", get(hello_world));

    Ok(router.into())
}
```

## Static Files

<CodeGroup>
```rust src/main.rs
use std::path::PathBuf;

use axum::{routing::get, Router};
use axum_extra::routing::SpaRouter;

async fn hello_world() -> &'static str {
    "Hello, world!"
}

#[shuttle_runtime::main]
async fn axum(
    // Name your static assets folder by passing `folder = <name>` to `StaticFolder`
    // If you don't pass a name, it will default to `static`.
    #[shuttle_static_folder::StaticFolder(folder = "assets")] static_folder: PathBuf,
) -> shuttle_axum::ShuttleAxum {
    let router = Router::new()
        .route("/hello", get(hello_world))
        .merge(SpaRouter::new("/assets", static_folder).index_file("index.html"));

    Ok(router.into())
}
```

```html assets/index.html
<!DOCTYPE html>
<html>
    <head>
        <title>Static Files</title>
    </head>
    <body>
        <p>This is an example of serving static files with Axum and Shuttle.</p>
    </body>
</html>
```
</CodeGroup>

## Websockets

<CodeGroup>
```rust src/main.rs
use std::{sync::Arc, time::Duration};

use axum::{
    extract::{
        ws::{Message, WebSocket},
        WebSocketUpgrade,
    },
    http::StatusCode,
    response::IntoResponse,
    routing::{get, get_service},
    Extension, Router,
};
use chrono::{DateTime, Utc};
use futures::{SinkExt, StreamExt};
use hyper::{Client, Uri};
use hyper_tls::HttpsConnector;
use serde::Serialize;
use shuttle_axum::ShuttleAxum;
use tokio::{
    sync::{watch, Mutex},
    time::sleep,
};
use tower_http::services::ServeDir;

struct State {
    clients_count: usize,
    rx: watch::Receiver<Message>,
}

const PAUSE_SECS: u64 = 15;
const STATUS_URI: &str = "https://api.shuttle.rs";

#[derive(Serialize)]
struct Response {
    clients_count: usize,
    #[serde(rename = "dateTime")]
    date_time: DateTime<Utc>,
    is_up: bool,
}

#[shuttle_runtime::main]
async fn axum(#[shuttle_static_folder::StaticFolder] static_folder: PathBuf) -> ShuttleAxum {
    let (tx, rx) = watch::channel(Message::Text("{}".to_string()));

    let state = Arc::new(Mutex::new(State {
        clients_count: 0,
        rx,
    }));

    // Spawn a thread to continually check the status of the api
    let state_send = state.clone();
    tokio::spawn(async move {
        let duration = Duration::from_secs(PAUSE_SECS);
        let https = HttpsConnector::new();
        let client = Client::builder().build::<_, hyper::Body>(https);
        let uri: Uri = STATUS_URI.parse().unwrap();

        loop {
            let is_up = client.get(uri.clone()).await;
            let is_up = is_up.is_ok();

            let response = Response {
                clients_count: state_send.lock().await.clients_count,
                date_time: Utc::now(),
                is_up,
            };
            let msg = serde_json::to_string(&response).unwrap();

            if tx.send(Message::Text(msg)).is_err() {
                break;
            }

            sleep(duration).await;
        }
    });

    let serve_dir = get_service(ServeDir::new(static_folder)).handle_error(handle_error);

    let router = Router::new()
        .route("/websocket", get(websocket_handler))
        .fallback_service(serve_dir)
        .layer(Extension(state));

    Ok(router.into())
}

async fn handle_error(_err: std::io::Error) -> impl IntoResponse {
    (StatusCode::INTERNAL_SERVER_ERROR, "Something went wrong...")
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    Extension(state): Extension<Arc<Mutex<State>>>,
) -> impl IntoResponse {
    ws.on_upgrade(|socket| websocket(socket, state))
}

async fn websocket(stream: WebSocket, state: Arc<Mutex<State>>) {
    // By splitting we can send and receive at the same time.
    let (mut sender, mut receiver) = stream.split();

    let mut rx = {
        let mut state = state.lock().await;
        state.clients_count += 1;
        state.rx.clone()
    };

    // This task will receive watch messages and forward it to this connected client.
    let mut send_task = tokio::spawn(async move {
        while let Ok(()) = rx.changed().await {
            let msg = rx.borrow().clone();

            if sender.send(msg).await.is_err() {
                break;
            }
        }
    });

    // This task will receive messages from this client.
    let mut recv_task = tokio::spawn(async move {
        while let Some(Ok(Message::Text(text))) = receiver.next().await {
            println!("this example does not read any messages, but got: {text}");
        }
    });

    // If any one of the tasks exit, abort the other.
    tokio::select! {
        _ = (&mut send_task) => recv_task.abort(),
        _ = (&mut recv_task) => send_task.abort(),
    };

    // This client disconnected
    state.lock().await.clients_count -= 1;
}
```

```html static/index.html
<!DOCTYPE html>
<html lang="en" class="bg-gray-600">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Websocket status page</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body
    class="flex justify-around items-center h-screen w-screen m-0 text-center"
  >
    <div
      class="flex max-w-sm flex-col overflow-hidden rounded-lg transition blur-md"
    >
      <div class="flex-shrink-0 bg-gray-800 text-slate-50 p-5">
        Current API status
      </div>
      <div
        id="is_ok"
        class="flex flex-1 flex-col justify-between p-6 bg-gray-500 text-xl font-bold uppercase"
      ></div>
    </div>
    <div
      class="flex max-w-sm flex-col overflow-hidden rounded-lg transition blur-md"
    >
      <div class="flex-shrink-0 bg-gray-800 text-slate-50 p-5">
        Last check time
      </div>
      <div
        id="dateTime"
        class="flex flex-1 flex-col justify-between p-6 bg-gray-500 text-xl font-bold"
      ></div>
    </div>
    <div
      class="flex max-w-sm flex-col overflow-hidden rounded-lg transition blur-md"
    >
      <div class="flex-shrink-0 bg-gray-800 text-slate-50 p-5">
        Clients watching
      </div>
      <div
        id="clients_count"
        class="flex flex-1 flex-col justify-between p-6 bg-gray-500 text-xl font-bold"
      ></div>
    </div>

    <button
      id="open"
      class="absolute text-2xl bg-gray-800 text-slate-50 p-2 rounded shadow-lg shadow-slate-800 hover:shadow-md scale-105 hover:scale-100 transition"
    >
      Open connection
    </button>

    <script type="text/javascript">
      const is_ok = document.querySelector('#is_ok');
      const dateTime = document.querySelector('#dateTime');
      const clients_count = document.querySelector('#clients_count');
      const button = document.querySelector('button');

      function track() {
        const proto = location.protocol.startsWith('https') ? 'wss' : 'ws';
        const websocket = new WebSocket(
          `${proto}://${window.location.host}/websocket`,
        );

        websocket.onopen = () => {
          console.log('connection opened');
          document
            .querySelectorAll('body > div')
            .forEach((e) => e.classList.remove('blur-md'));
          document.querySelector('body > button').classList.add('hidden');
        };

        websocket.onclose = () => {
          console.log('connection closed');
          document
            .querySelectorAll('body > div')
            .forEach((e) => e.classList.add('blur-md'));
          document.querySelector('body > button').classList.remove('hidden');
        };

        websocket.onmessage = (e) => {
          const response = JSON.parse(e.data);

          if (response.is_up) {
            is_ok.textContent = 'up';
            is_ok.classList.add('text-green-600');
            is_ok.classList.remove('text-rose-700');
          } else {
            is_ok.textContent = 'down';
            is_ok.classList.add('text-rose-700');
            is_ok.classList.remove('text-green-600');
          }

          dateTime.textContent = new Date(response.dateTime).toLocaleString();
          clients_count.textContent = response.clients_count;
        };
      }

      track();
      button.addEventListener('click', track);
    </script>
  </body>
</html>
```
</CodeGroup>
---
<Tip> If you want to explore other frameworks, we have more examples with popular ones like Tower and Warp. You can find them [right here](../examples/other). </Tip>
